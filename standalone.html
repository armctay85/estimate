<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EstiMate - Professional Construction Cost Estimator & Takeoff Tool Australia</title>
  <meta name="description" content="Professional construction cost estimator and takeoff tool for Australian builders, contractors, and quantity surveyors. Calculate material costs, measure floor plans, and generate accurate construction estimates. Free online tool with advanced features.">
  <meta name="keywords" content="construction estimator, takeoff tool, cost calculator, Australian builders, quantity surveyor, floor plan measurement, material costs, construction quotes, building estimator, contractor tools">
  <meta name="author" content="EstiMate">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://estimate-construction.replit.app/standalone.html">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://estimate-construction.replit.app/standalone.html">
  <meta property="og:title" content="EstiMate - Professional Construction Cost Estimator Australia">
  <meta property="og:description" content="Free professional construction estimator and takeoff tool for Australian builders. Calculate material costs, measure floor plans, generate accurate quotes.">
  <meta property="og:image" content="https://estimate-construction.replit.app/og-image.jpg">
  <meta property="og:site_name" content="EstiMate">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://estimate-construction.replit.app/standalone.html">
  <meta property="twitter:title" content="EstiMate - Professional Construction Cost Estimator Australia">
  <meta property="twitter:description" content="Free professional construction estimator and takeoff tool for Australian builders. Calculate material costs, measure floor plans, generate accurate quotes.">
  <meta property="twitter:image" content="https://estimate-construction.replit.app/og-image.jpg">
  
  <!-- Geo Tags -->
  <meta name="geo.region" content="AU">
  <meta name="geo.country" content="Australia">
  <meta name="geo.placename" content="Australia">
  
  <!-- Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "EstiMate",
    "description": "Professional construction cost estimator and takeoff tool for Australian builders and contractors",
    "url": "https://estimate-construction.replit.app/standalone.html",
    "applicationCategory": "BusinessApplication",
    "operatingSystem": "Web Browser",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "AUD"
    },
    "creator": {
      "@type": "Organization",
      "name": "EstiMate",
      "url": "https://estimate-construction.replit.app"
    },
    "featureList": [
      "Construction cost estimation",
      "Floor plan takeoff",
      "Material cost calculation",
      "Australian building costs",
      "CSV export",
      "Project management"
    ],
    "screenshot": "https://estimate-construction.replit.app/app-screenshot.jpg"
  }
  </script>
  
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%232563eb' rx='4'/><path d='M8 12h16v2H8zm0 4h12v2H8zm0 4h16v2H8z' fill='white'/></svg>">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect width='180' height='180' fill='%232563eb' rx='20'/><path d='M40 60h100v10H40zm0 20h80v10H40zm0 20h100v10H40z' fill='white'/></svg>">
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --secondary: #f97316;
      --accent: #10b981;
      --surface: #ffffff;
      --surface-2: #f8fafc;
      --border: #e2e8f0;
      --text: #1e293b;
      --text-muted: #64748b;
      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    }
    
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 24px;
      padding: 16px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      border-radius: 12px;
      color: white;
      box-shadow: var(--shadow-lg);
    }
    
    .logo-icon {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    
    .logo-text h1 {
      font-size: 24px;
      font-weight: 700;
      margin: 0;
      letter-spacing: -0.025em;
    }
    
    .logo-text p {
      font-size: 13px;
      margin: 0;
      opacity: 0.9;
      font-weight: 400;
    }
    
    .sidebar { 
      width: 340px; 
      background: var(--surface);
      border-right: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    
    .canvas-container { 
      flex: 1; 
      position: relative; 
      background: var(--surface-2);
    }
    
    #canvas { 
      border: 1px solid var(--border);
      background: var(--surface);
      border-radius: 8px;
      box-shadow: var(--shadow);
    }
    
    .section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: var(--shadow);
    }
    
    .section-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .section-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
    }
    
    .tool-btn { 
      transition: all 0.2s ease;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      border-radius: 8px;
      padding: 12px 16px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .tool-btn:hover { 
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      border-color: var(--primary);
    }
    
    .tool-btn.active { 
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      border-color: var(--primary);
      box-shadow: var(--shadow-lg);
    }
    
    .premium-feature { 
      opacity: 0.7; 
      pointer-events: none; 
      position: relative; 
    }
    
    .premium-feature::after { 
      content: 'Pro'; 
      position: absolute; 
      top: 0; 
      right: 0; 
      background: linear-gradient(135deg, var(--secondary), #ea580c);
      color: white;
      padding: 4px 8px; 
      font-size: 10px; 
      border-radius: 0 8px 0 8px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .material-btn {
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      transition: all 0.2s ease;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .material-btn:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow);
    }
    
    .material-btn.active {
      border-color: var(--primary);
      background: var(--primary);
      color: white;
      box-shadow: var(--shadow-lg);
    }
    
    .room-item {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.2s ease;
    }
    
    .room-item:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow);
    }
    
    .cost-display {
      background: linear-gradient(135deg, var(--accent), #059669);
      color: white;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      box-shadow: var(--shadow-lg);
    }
    
    .cost-amount {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    
    .cost-label {
      font-size: 14px;
      opacity: 0.9;
      font-weight: 500;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      transition: all 0.2s ease;
      box-shadow: var(--shadow);
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .btn-secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .btn-secondary:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow);
    }
    
    .input-field {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      background: var(--surface);
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .input-field:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }
    
    .ad-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(90deg, var(--text), var(--text-muted));
      color: white;
      padding: 12px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
      box-shadow: var(--shadow-lg);
    }
    
    .gradient-text {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .glass-effect {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .animate-slide-in {
      animation: slideIn 0.3s ease-out;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="flex h-screen">
    <!-- Sidebar -->
    <div class="sidebar p-4 overflow-y-auto">
      <div class="logo animate-slide-in">
        <div class="logo-icon">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 7h-3V4a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H5a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1zM10 6h4v1h-4V6zm8 12H6V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v9z"/>
            <path d="M8 11h2v2H8zm4 0h2v2h-2zm4 0h2v2h-2zm-8 4h2v2H8zm4 0h2v2h-2z"/>
          </svg>
        </div>
        <div class="logo-text">
          <h1>EstiMate</h1>
          <p>Australian Construction Cost Estimator</p>
        </div>
      </div>
      
      <!-- Tools -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Drawing Tools</h2>
        <div class="grid grid-cols-2 gap-2">
          <button onclick="setShape('rectangle')" class="tool-btn bg-gray-200 hover:bg-gray-300 p-3 rounded-lg text-sm font-medium" id="rect-btn">Rectangle</button>
          <button onclick="setShape('circle')" class="tool-btn bg-gray-200 hover:bg-gray-300 p-3 rounded-lg text-sm font-medium" id="circle-btn">Circle</button>
          <button onclick="setShape('polygon')" class="tool-btn bg-gray-200 hover:bg-gray-300 p-3 rounded-lg text-sm font-medium" id="polygon-btn">Polygon</button>
          <button onclick="setShape('line')" class="tool-btn bg-gray-200 hover:bg-gray-300 p-3 rounded-lg text-sm font-medium" id="line-btn">Line</button>
          <button onclick="setShape('freehand')" class="tool-btn bg-gray-200 hover:bg-gray-300 p-3 rounded-lg text-sm font-medium" id="freehand-btn">Freehand</button>
        </div>
        <p class="text-xs text-gray-500 mt-2">💡 Polygon: Click points, double-click to finish</p>
      </div>
      
      <!-- Materials -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Floor Materials</h2>
        <select id="material-select" onchange="setMaterial(this.value)" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500">
          <option value="timber">🌳 Timber ($100/m²)</option>
          <option value="carpet">🪑 Carpet ($40/m²)</option>
          <option value="tiles">🏺 Tiles ($60/m²)</option>
          <option value="laminate">📋 Laminate ($30/m²)</option>
          <option value="vinyl">💿 Vinyl ($25/m²)</option>
        </select>
        
        <!-- Add Custom Material -->
        <details class="mt-3">
          <summary class="text-sm text-blue-600 cursor-pointer">Add Custom Material</summary>
          <div class="mt-2 space-y-2">
            <input id="custom-mat-name" placeholder="Material name" class="w-full p-2 text-sm border rounded">
            <div class="flex gap-2">
              <input id="custom-mat-color" type="color" value="#8B4513" class="w-16 h-8 border rounded">
              <input id="custom-mat-cost" placeholder="Cost $/m²" type="number" class="flex-1 p-2 text-sm border rounded">
            </div>
            <button onclick="addCustomMaterial()" class="bg-green-500 hover:bg-green-600 text-white p-2 rounded w-full text-sm">Add Material</button>
          </div>
        </details>
      </div>
      
      <!-- Templates -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Quick Templates</h2>
        <select id="template-select" class="w-full p-2 border rounded-lg mb-2 text-sm">
          <option value="">Select a template...</option>
        </select>
        <button onclick="addTemplate()" class="bg-purple-500 hover:bg-purple-600 text-white p-2 rounded-lg w-full text-sm font-medium">Add Template</button>
      </div>
      
      <!-- Rooms List -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Project Elements</h2>
        <div id="rooms-list" class="max-h-64 overflow-y-auto"></div>
      </div>
      
      <!-- Total Cost -->
      <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
        <h2 class="font-semibold mb-2 text-blue-800">Total Project Cost</h2>
        <p id="total-cost" class="text-2xl font-bold text-blue-600">$0 AUD</p>
      </div>
      
      <!-- Measurement & Scale -->
      <div class="mb-6 border-t pt-4">
        <h2 class="font-semibold mb-3 text-gray-700">Measurement & Scale</h2>
        <div class="bg-blue-50 p-3 rounded-lg mb-3">
          <p class="text-xs text-blue-800 mb-2">Current Scale: <span id="scale-display">100 pixels = 1m</span></p>
          <button onclick="startCalibration()" class="bg-blue-500 hover:bg-blue-600 text-white p-2 rounded-lg w-full text-sm font-medium">Calibrate Scale</button>
        </div>
      </div>

      <!-- Controls -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Canvas Controls</h2>
        <div class="grid grid-cols-2 gap-2 mb-3">
          <button onclick="addElement()" class="bg-blue-500 hover:bg-blue-600 text-white p-2 rounded-lg text-sm font-medium">Add Element</button>
          <button onclick="clearCanvas()" class="bg-red-500 hover:bg-red-600 text-white p-2 rounded-lg text-sm font-medium">Clear All</button>
          <button onclick="toggleGrid()" class="bg-gray-500 hover:bg-gray-600 text-white p-2 rounded-lg text-sm font-medium">Toggle Grid</button>
          <button onclick="zoomToFit()" class="bg-gray-500 hover:bg-gray-600 text-white p-2 rounded-lg text-sm font-medium">Zoom Fit</button>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <button onclick="zoomIn()" class="bg-gray-500 hover:bg-gray-600 text-white p-2 rounded-lg text-sm font-medium">Zoom +</button>
          <button onclick="zoomOut()" class="bg-gray-500 hover:bg-gray-600 text-white p-2 rounded-lg text-sm font-medium">Zoom -</button>
        </div>
      </div>
      
      <!-- Background -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Base Layer</h2>
        <input type="file" id="bg-file" onchange="loadBackground()" class="w-full mb-2 text-sm" accept=".pdf,.dwg,.dxf,.jpg,.jpeg,.png">
        <button onclick="removeBackground()" class="bg-red-500 hover:bg-red-600 text-white p-2 rounded-lg w-full mb-3 text-sm font-medium">Remove Background</button>
        <label class="block text-sm text-gray-600">
          Opacity: 
          <input type="range" min="0" max="1" step="0.1" value="0.7" onchange="setBgOpacity(this.value)" class="w-full">
        </label>
      </div>
      
      <!-- Export/Save -->
      <div class="mb-6">
        <h2 class="font-semibold mb-3 text-gray-700">Export & Save</h2>
        <button onclick="exportToPDF()" class="bg-green-500 text-white p-2 rounded-lg w-full mb-2 text-sm font-medium premium-feature">Export PDF Report</button>
        <button onclick="exportToCSV()" class="bg-green-500 hover:bg-green-600 text-white p-2 rounded-lg w-full mb-2 text-sm font-medium">Export CSV</button>
        <button onclick="saveProject()" class="bg-blue-500 hover:bg-blue-600 text-white p-2 rounded-lg w-full mb-2 text-sm font-medium">Save Project</button>
        <input type="file" id="load-file" onchange="loadProject()" class="w-full text-sm" accept=".json">
      </div>
      
      <!-- Premium Features -->
      <div class="mb-6 border-t pt-4">
        <h2 class="font-semibold mb-2 text-yellow-600">Premium Features</h2>
        <p class="text-sm mb-3 text-gray-600">Unlock professional tools for $19.99/month</p>
        <button onclick="subscribe()" class="bg-gradient-to-r from-yellow-400 to-yellow-500 hover:from-yellow-500 hover:to-yellow-600 text-white p-3 rounded-lg w-full font-semibold mb-3">Upgrade to Pro</button>
        <ul class="text-sm text-gray-600 space-y-1">
          <li>✨ Unlimited PDF Exports</li>
          <li>🤝 Team Collaboration</li>
          <li>📚 Template Library</li>
          <li>🚫 Ad-Free Experience</li>
          <li>📊 Advanced Reports</li>
        </ul>
      </div>
      
      <!-- Share -->
      <div>
        <h2 class="font-semibold mb-3 text-gray-700">Share Project</h2>
        <button onclick="shareProject()" class="bg-indigo-500 hover:bg-indigo-600 text-white p-2 rounded-lg w-full text-sm font-medium">Generate Share Link</button>
      </div>
    </div>
    
    <!-- Canvas -->
    <div class="canvas-container flex flex-col">
      <div class="p-4 bg-white border-b border-gray-200">
        <div class="flex items-center justify-between">
          <h3 class="font-semibold text-gray-700">Drawing Canvas</h3>
          <div class="text-sm text-gray-500">
            Drag to draw shapes • Shift+click to pan • Scroll to zoom
          </div>
        </div>
      </div>
      <div class="flex-1 p-4">
        <canvas id="canvas" class="rounded-lg shadow-sm"></canvas>
        
        <!-- SEO Content Section -->
        <div class="mt-8 bg-white p-6 rounded-lg shadow-sm border">
          <h3 class="text-lg font-semibold mb-4 text-gray-800">About EstiMate - Australia's Leading Construction Cost Estimator</h3>
          <div class="grid md:grid-cols-2 gap-6 text-sm text-gray-600">
            <div>
              <h4 class="font-semibold text-gray-800 mb-2">For Australian Builders & Contractors</h4>
              <p>EstiMate is specifically designed for the Australian construction industry, featuring local material costs, metric measurements, and compliance with Australian building standards. Perfect for residential builders, commercial contractors, and quantity surveyors across NSW, VIC, QLD, WA, SA, TAS, ACT, and NT.</p>
            </div>
            <div>
              <h4 class="font-semibold text-gray-800 mb-2">Professional Takeoff Features</h4>
              <ul class="space-y-1">
                <li>• Accurate floor plan measurement tools</li>
                <li>• Real-time material cost calculation</li>
                <li>• Australian standard building materials</li>
                <li>• CSV export for quotes and estimates</li>
                <li>• Calibrated scaling for precise measurements</li>
                <li>• Template library for common room types</li>
              </ul>
            </div>
          </div>
          
          <div class="mt-6 pt-4 border-t">
            <h4 class="font-semibold text-gray-800 mb-2">Construction Cost Categories</h4>
            <div class="flex flex-wrap gap-2">
              <span class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-xs">Flooring Costs</span>
              <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-xs">Timber Flooring</span>
              <span class="bg-purple-100 text-purple-800 px-3 py-1 rounded-full text-xs">Carpet Installation</span>
              <span class="bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-xs">Tile Laying</span>
              <span class="bg-red-100 text-red-800 px-3 py-1 rounded-full text-xs">Laminate Flooring</span>
              <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-xs">Vinyl Planks</span>
            </div>
          </div>
          
          <div class="mt-6 pt-4 border-t">
            <h4 class="font-semibold text-gray-800 mb-2">How to Use EstiMate for Construction Estimates</h4>
            <ol class="space-y-2 text-sm">
              <li><strong>1. Draw Your Floor Plan:</strong> Use our intuitive drawing tools to sketch rooms, walls, and spaces directly on the canvas.</li>
              <li><strong>2. Select Materials:</strong> Choose from Australian standard materials including timber, carpet, tiles, laminate, and vinyl flooring.</li>
              <li><strong>3. Calibrate Scale:</strong> Set accurate measurements by calibrating the scale to real-world dimensions.</li>
              <li><strong>4. Calculate Costs:</strong> Get instant cost estimates based on current Australian material prices and labor rates.</li>
              <li><strong>5. Export Reports:</strong> Generate professional CSV reports for client quotes and project documentation.</li>
            </ol>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Australian Materials with proper costs (now customizable)
    let MATERIALS = {
      timber: { color: '#D2B48C', cost: 100 },
      carpet: { color: '#8B4513', cost: 40 },
      tiles: { color: '#708090', cost: 60 },
      laminate: { color: '#DEB887', cost: 30 },
      vinyl: { color: '#2F4F4F', cost: 25 }
    };

    // Templates for common construction elements
    const TEMPLATES = [
      { name: 'Standard Room', shape: 'rectangle', width: 400, height: 300, material: 'carpet' },
      { name: 'Kitchen', shape: 'rectangle', width: 350, height: 250, material: 'tiles' },
      { name: 'Bathroom', shape: 'rectangle', width: 200, height: 150, material: 'tiles' },
      { name: 'Hallway', shape: 'rectangle', width: 120, height: 800, material: 'laminate' },
      { name: 'Living Area', shape: 'rectangle', width: 500, height: 400, material: 'timber' },
      { name: 'Wall Section', shape: 'rectangle', width: 500, height: 20, material: 'timber' },
      { name: 'Door Opening', shape: 'rectangle', width: 90, height: 210, material: 'timber' }
    ];

    // Enhanced CanvasManager Implementation
    class CanvasManager {
      constructor(canvasElement) {
        this.canvas = new fabric.Canvas(canvasElement, {
          width: 800,
          height: 500,
          backgroundColor: "#F9FAFB",
          selection: true,
          enableRetinaScaling: false,
          preserveObjectStacking: true,
          imageSmoothingEnabled: false,
          renderOnAddRemove: false,
        });

        this.rooms = new Map();
        this.selectedMaterial = "timber";
        this.currentShape = "rectangle";
        this.isDrawing = false;
        this.drawingStartPoint = null;
        this.previewShape = null;
        this.polygonPoints = [];
        this.drawingPath = null;
        this.backgroundImage = null;
        this.gridVisible = true;
        this.gridGroup = null;
        this.zoomLevel = 1;
        this.isPanning = false;
        this.panStartPoint = null;
        this.onRoomsChange = null;
        this.scaleFactor = 100; // Default: 100 pixels = 1 meter
        this.isCalibrating = false;
        this.calibrationLine = null;

        this.setupEventListeners();
        this.setupDrawingEvents();
        this.setupZoomAndPan();
        this.createGrid();
        this.canvas.renderAll();
      }

      createGrid() {
        const gridSize = 20;
        const canvasWidth = this.canvas.getWidth();
        const canvasHeight = this.canvas.getHeight();
        const lines = [];

        for (let i = 0; i <= canvasWidth; i += gridSize) {
          lines.push(new fabric.Line([i, 0, i, canvasHeight], {
            stroke: '#E5E7EB',
            strokeWidth: i % (gridSize * 5) === 0 ? 1.5 : 0.5,
            selectable: false,
            evented: false,
          }));
        }

        for (let i = 0; i <= canvasHeight; i += gridSize) {
          lines.push(new fabric.Line([0, i, canvasWidth, i], {
            stroke: '#E5E7EB',
            strokeWidth: i % (gridSize * 5) === 0 ? 1.5 : 0.5,
            selectable: false,
            evented: false,
          }));
        }

        this.gridGroup = new fabric.Group(lines, {
          selectable: false,
          evented: false,
          opacity: 0.7,
        });

        this.canvas.add(this.gridGroup);
        this.gridGroup.visible = this.gridVisible;
        this.canvas.renderAll();
      }

      setupZoomAndPan() {
        this.canvas.on('mouse:wheel', (opt) => {
          const delta = opt.e.deltaY;
          let zoom = this.canvas.getZoom();
          zoom *= 0.999 ** delta;
          
          if (zoom > 20) zoom = 20;
          if (zoom < 0.1) zoom = 0.1;
          
          this.zoomLevel = zoom;
          this.canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
          
          opt.e.preventDefault();
          opt.e.stopPropagation();
        });

        this.canvas.on('mouse:down', (opt) => {
          const evt = opt.e;
          if (evt.button === 1 || (evt.button === 0 && evt.shiftKey)) {
            this.isPanning = true;
            this.canvas.selection = false;
            this.panStartPoint = { x: evt.clientX, y: evt.clientY };
            opt.e.preventDefault();
          }
        });

        this.canvas.on('mouse:move', (opt) => {
          if (this.isPanning && this.panStartPoint) {
            const evt = opt.e;
            const vpt = this.canvas.viewportTransform;
            vpt[4] += evt.clientX - this.panStartPoint.x;
            vpt[5] += evt.clientY - this.panStartPoint.y;
            this.canvas.requestRenderAll();
            this.panStartPoint = { x: evt.clientX, y: evt.clientY };
          }
        });

        this.canvas.on('mouse:up', () => {
          if (this.isPanning) {
            this.isPanning = false;
            this.canvas.selection = true;
            this.panStartPoint = null;
          }
        });
      }

      setupEventListeners() {
        this.canvas.on("object:modified", this.handleObjectModified.bind(this));
        this.canvas.on("mouse:dblclick", this.handleMouseDoubleClick.bind(this));
        this.canvas.selection = true;
        this.canvas.skipTargetFind = false;
      }

      setupDrawingEvents() {
        this.canvas.on("mouse:down", this.handleMouseDown.bind(this));
        this.canvas.on("mouse:move", this.handleMouseMove.bind(this));
        this.canvas.on("mouse:up", this.handleMouseUp.bind(this));
      }

      handleMouseDown(e) {
        if (this.isPanning) return;

        const pointer = this.canvas.getPointer(e.e);

        switch (this.currentShape) {
          case "freehand":
            this.isDrawing = true;
            this.drawingPath = new fabric.Path(`M ${pointer.x} ${pointer.y}`, {
              stroke: MATERIALS[this.selectedMaterial].color,
              strokeWidth: 3,
              fill: "",
              selectable: false,
            });
            this.canvas.add(this.drawingPath);
            break;

          case "rectangle":
            this.drawingStartPoint = pointer;
            this.isDrawing = true;
            this.previewShape = new fabric.Rect({
              left: pointer.x,
              top: pointer.y,
              width: 0,
              height: 0,
              fill: `${MATERIALS[this.selectedMaterial].color}40`,
              stroke: MATERIALS[this.selectedMaterial].color,
              strokeWidth: 2,
              selectable: false,
              evented: false,
            });
            this.canvas.add(this.previewShape);
            break;

          case "circle":
            this.drawingStartPoint = pointer;
            this.isDrawing = true;
            this.previewShape = new fabric.Circle({
              left: pointer.x,
              top: pointer.y,
              radius: 0,
              fill: `${MATERIALS[this.selectedMaterial].color}40`,
              stroke: MATERIALS[this.selectedMaterial].color,
              strokeWidth: 2,
              selectable: false,
              evented: false,
            });
            this.canvas.add(this.previewShape);
            break;

          case "line":
            this.drawingStartPoint = pointer;
            this.isDrawing = true;
            this.previewShape = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
              stroke: MATERIALS[this.selectedMaterial].color,
              strokeWidth: 4,
              selectable: false,
              evented: false,
            });
            this.canvas.add(this.previewShape);
            break;

          case "polygon":
            this.polygonPoints.push(pointer);
            if (this.polygonPoints.length === 1) {
              this.isDrawing = true;
            }
            break;
        }
      }

      handleMouseMove(e) {
        const pointer = this.canvas.getPointer(e.e);

        if (this.currentShape === "freehand" && this.isDrawing && this.drawingPath) {
          const path = this.drawingPath.path;
          path.push(["L", pointer.x, pointer.y]);
          this.drawingPath.path = path;
          this.canvas.renderAll();
          return;
        }

        if (!this.isDrawing || !this.drawingStartPoint) return;

        switch (this.currentShape) {
          case "rectangle":
            const width = pointer.x - this.drawingStartPoint.x;
            const height = pointer.y - this.drawingStartPoint.y;
            this.previewShape.set({
              left: width < 0 ? pointer.x : this.drawingStartPoint.x,
              top: height < 0 ? pointer.y : this.drawingStartPoint.y,
              width: Math.abs(width),
              height: Math.abs(height),
            });
            this.canvas.renderAll();
            break;

          case "circle":
            const dx = pointer.x - this.drawingStartPoint.x;
            const dy = pointer.y - this.drawingStartPoint.y;
            const radius = Math.sqrt(dx * dx + dy * dy);
            this.previewShape.set({
              left: this.drawingStartPoint.x - radius,
              top: this.drawingStartPoint.y - radius,
              radius,
            });
            this.canvas.renderAll();
            break;

          case "line":
            this.previewShape.set({
              x2: pointer.x,
              y2: pointer.y,
            });
            this.canvas.renderAll();
            break;
        }
      }

      handleMouseUp(e) {
        if (this.currentShape === "freehand" && this.isDrawing) {
          this.isDrawing = false;
          if (this.drawingPath) {
            this.drawingPath.selectable = true;
            this.convertPathToRoom(this.drawingPath);
            this.drawingPath = null;
          }
          return;
        }

        if (!this.isDrawing || !this.previewShape) return;

        this.previewShape.selectable = true;
        this.previewShape.evented = true;
        const bounds = this.previewShape.getBoundingRect();

        // Handle calibration for lines
        if (this.isCalibrating && this.currentShape === 'line') {
          const line = this.previewShape;
          const lineLength = Math.sqrt(
            Math.pow(line.x2 - line.x1, 2) + Math.pow(line.y2 - line.y1, 2)
          );
          this.calibrationLine = line;
          this.finishCalibration(lineLength);
          return;
        }

        const room = {
          id: Date.now().toString(),
          name: `${this.currentShape.charAt(0).toUpperCase() + this.currentShape.slice(1)} Room`,
          width: bounds.width,
          height: bounds.height,
          material: this.selectedMaterial,
          cost: 0,
          positionX: bounds.left,
          positionY: bounds.top,
          shapeType: this.currentShape,
          fabricObject: this.previewShape,
        };
        room.cost = this.calculateRoomCost(room);
        this.rooms.set(room.id, room);
        this.notifyRoomsChange();

        this.previewShape = null;
        this.drawingStartPoint = null;
        this.isDrawing = false;
        this.canvas.renderAll();
      }

      handleMouseDoubleClick(e) {
        if (this.currentShape !== "polygon" || !this.isDrawing || this.polygonPoints.length < 3) return;

        if (this.previewShape) {
          this.canvas.remove(this.previewShape);
          this.previewShape = null;
        }

        const poly = new fabric.Polygon(this.polygonPoints, {
          fill: `${MATERIALS[this.selectedMaterial].color}40`,
          stroke: MATERIALS[this.selectedMaterial].color,
          strokeWidth: 2,
          selectable: true,
          evented: true,
        });
        this.canvas.add(poly);
        const bounds = poly.getBoundingRect();
        const room = {
          id: Date.now().toString(),
          name: "Polygon Room",
          width: bounds.width,
          height: bounds.height,
          material: this.selectedMaterial,
          cost: 0,
          positionX: bounds.left,
          positionY: bounds.top,
          shapeType: "polygon",
          points: this.polygonPoints.flatMap((p) => [p.x, p.y]),
          fabricObject: poly,
        };
        room.cost = this.calculateRoomCost(room);
        this.rooms.set(room.id, room);
        this.notifyRoomsChange();

        this.polygonPoints = [];
        this.isDrawing = false;
        this.canvas.renderAll();
      }

      convertPathToRoom(path) {
        const bounds = path.getBoundingRect();
        const pathCommands = path.path || [];
        const points = [];
        pathCommands.forEach((cmd) => {
          if (cmd[0] === "M" || cmd[0] === "L") {
            points.push({ x: cmd[1], y: cmd[2] });
          }
        });
        const room = {
          id: Date.now().toString(),
          name: "Freehand Room",
          width: bounds.width,
          height: bounds.height,
          material: this.selectedMaterial,
          cost: 0,
          positionX: bounds.left,
          positionY: bounds.top,
          shapeType: "freehand",
          points: points.flatMap((p) => [p.x, p.y]),
          fabricObject: path,
        };
        room.cost = this.calculateRoomCost(room);
        this.rooms.set(room.id, room);
        this.notifyRoomsChange();
      }

      handleObjectModified(e) {
        const obj = e.target;
        if (!obj) return;

        for (const [id, room] of this.rooms) {
          if (room.fabricObject === obj) {
            const bounds = obj.getBoundingRect();
            room.width = bounds.width;
            room.height = bounds.height;
            room.positionX = bounds.left;
            room.positionY = bounds.top;
            room.cost = this.calculateRoomCost(room);
            this.notifyRoomsChange();
            break;
          }
        }
      }

      calculateRoomCost(room) {
        // Convert canvas pixels to real-world square meters using scale factor
        const areaSquareMeters = (room.width * room.height) / (this.scaleFactor * this.scaleFactor);
        return Math.round(areaSquareMeters * MATERIALS[room.material].cost);
      }

      // Scaling and measurement methods
      setScale(calibrationLengthPixels, realLengthMeters) {
        this.scaleFactor = calibrationLengthPixels / realLengthMeters;
        // Recalculate all room costs
        this.rooms.forEach(room => {
          room.cost = this.calculateRoomCost(room);
        });
        this.notifyRoomsChange();
        updateScaleDisplay();
      }

      startCalibration() {
        this.isCalibrating = true;
        this.currentShape = 'line';
        alert('Draw a line on a known distance, then enter the real-world length in meters.');
      }

      finishCalibration(lineLength) {
        const realLength = prompt('Enter the real-world length of this line in meters:');
        if (realLength && !isNaN(realLength) && realLength > 0) {
          this.setScale(lineLength, parseFloat(realLength));
          alert(`Scale set: ${this.scaleFactor.toFixed(1)} pixels per meter`);
        }
        this.isCalibrating = false;
        this.calibrationLine = null;
      }

      // Template methods
      addTemplate(template) {
        const shape = this.createTemplateShape(template);
        const centerX = this.canvas.getWidth() / 2;
        const centerY = this.canvas.getHeight() / 2;
        
        shape.set({
          left: centerX - template.width / 2,
          top: centerY - template.height / 2,
        });

        this.canvas.add(shape);
        this.canvas.setActiveObject(shape);
        this.canvas.renderAll();

        const bounds = shape.getBoundingRect();
        const room = {
          id: Date.now().toString(),
          name: template.name,
          width: template.width,
          height: template.height,
          material: template.material,
          cost: this.calculateRoomCost({ width: template.width, height: template.height, material: template.material }),
          positionX: bounds.left,
          positionY: bounds.top,
          shapeType: template.shape,
          fabricObject: shape,
        };

        this.rooms.set(room.id, room);
        this.notifyRoomsChange();
        return room;
      }

      createTemplateShape(template) {
        const baseStyle = {
          fill: `${MATERIALS[template.material].color}40`,
          stroke: MATERIALS[template.material].color,
          strokeWidth: 2,
          selectable: true,
          evented: true,
        };

        switch (template.shape) {
          case "rectangle":
            return new fabric.Rect({ ...baseStyle, width: template.width, height: template.height });
          case "circle":
            return new fabric.Circle({ ...baseStyle, radius: template.width / 2 });
          default:
            return new fabric.Rect({ ...baseStyle, width: template.width, height: template.height });
        }
      }

      // Custom material methods
      addCustomMaterial(name, color, cost) {
        MATERIALS[name.toLowerCase()] = { color, cost };
        this.updateMaterialSelect();
      }

      updateMaterialSelect() {
        const select = document.getElementById('material-select');
        select.innerHTML = '';
        Object.keys(MATERIALS).forEach(key => {
          const opt = document.createElement('option');
          opt.value = key;
          const icon = this.getMaterialIcon(key);
          opt.textContent = `${icon} ${key.charAt(0).toUpperCase() + key.slice(1)} ($${MATERIALS[key].cost}/m²)`;
          select.appendChild(opt);
        });
      }

      getMaterialIcon(material) {
        const icons = {
          timber: '🌳', carpet: '🪑', tiles: '🏺', laminate: '📋', vinyl: '💿',
          concrete: '🧱', steel: '⚙️', stone: '🪨', glass: '🔷'
        };
        return icons[material] || '📐';
      }

      // Public methods
      setCurrentShape(shape) {
        this.currentShape = shape;
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(shape + '-btn').classList.add('active');
      }

      setSelectedMaterial(material) {
        this.selectedMaterial = material;
      }

      addRoom() {
        const centerX = this.canvas.getWidth() / 2;
        const centerY = this.canvas.getHeight() / 2;
        
        const shape = this.createShape();
        shape.set({
          left: centerX - 50,
          top: centerY - 40,
        });

        this.canvas.add(shape);
        this.canvas.setActiveObject(shape);
        this.canvas.renderAll();

        const bounds = shape.getBoundingRect();
        const room = {
          id: Date.now().toString(),
          name: "New Room",
          width: bounds.width,
          height: bounds.height,
          material: this.selectedMaterial,
          cost: this.calculateRoomCost({ width: bounds.width, height: bounds.height, material: this.selectedMaterial }),
          positionX: centerX - 50,
          positionY: centerY - 40,
          shapeType: this.currentShape,
          fabricObject: shape,
        };

        this.rooms.set(room.id, room);
        this.notifyRoomsChange();
        return room;
      }

      createShape() {
        const baseStyle = {
          fill: `${MATERIALS[this.selectedMaterial].color}40`,
          stroke: MATERIALS[this.selectedMaterial].color,
          strokeWidth: 2,
          selectable: true,
          evented: true,
        };

        switch (this.currentShape) {
          case "rectangle":
            return new fabric.Rect({ ...baseStyle, width: 100, height: 80 });
          case "circle":
            return new fabric.Circle({ ...baseStyle, radius: 50 });
          case "polygon":
            const points = [
              { x: 50, y: 0 }, { x: 100, y: 25 }, { x: 75, y: 75 }, { x: 25, y: 75 }, { x: 0, y: 25 }
            ];
            return new fabric.Polygon(points, baseStyle);
          case "line":
            return new fabric.Line([0, 0, 100, 100], { ...baseStyle, strokeWidth: 4 });
          default:
            return new fabric.Rect({ ...baseStyle, width: 100, height: 80 });
        }
      }

      clearCanvas() {
        this.canvas.clear();
        this.rooms.clear();
        this.backgroundImage = null;
        this.createGrid();
        this.canvas.renderAll();
        this.notifyRoomsChange();
      }

      toggleGrid() {
        this.gridVisible = !this.gridVisible;
        if (this.gridGroup) {
          this.gridGroup.visible = this.gridVisible;
          this.canvas.renderAll();
        }
      }

      zoomIn() {
        const zoom = Math.min(this.zoomLevel * 1.2, 20);
        this.canvas.setZoom(zoom);
        this.zoomLevel = zoom;
      }

      zoomOut() {
        const zoom = Math.max(this.zoomLevel * 0.8, 0.1);
        this.canvas.setZoom(zoom);
        this.zoomLevel = zoom;
      }

      zoomToFit() {
        this.canvas.setZoom(1);
        this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
        this.zoomLevel = 1;
      }

      async loadBackgroundImage(file) {
        try {
          const dataUrl = await this.fileToDataUrl(file);
          await this.loadImageFromDataUrl(dataUrl, file.name);
        } catch (error) {
          // Create visual placeholder for unsupported formats
          this.createVisualBackgroundLayer(file);
        }
      }

      fileToDataUrl(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      loadImageFromDataUrl(dataUrl, filename) {
        return new Promise((resolve, reject) => {
          const imgElement = new Image();
          imgElement.onload = () => {
            const canvasWidth = this.canvas.getWidth();
            const canvasHeight = this.canvas.getHeight();
            
            const scaleX = canvasWidth / imgElement.width;
            const scaleY = canvasHeight / imgElement.height;
            const scale = Math.min(scaleX, scaleY);
            
            const img = new fabric.Image(imgElement, {
              left: 0,
              top: 0,
              selectable: false,
              evented: false,
              opacity: 0.7,
              scaleX: scale,
              scaleY: scale,
            });
            
            if (this.backgroundImage) {
              this.canvas.remove(this.backgroundImage);
            }
            
            this.backgroundImage = img;
            this.canvas.add(img);
            this.canvas.sendToBack(img);
            this.canvas.renderAll();
            resolve();
          };
          imgElement.onerror = () => reject(new Error(`Failed to load: ${filename}`));
          imgElement.src = dataUrl;
        });
      }

      createVisualBackgroundLayer(file) {
        if (this.backgroundImage) {
          this.canvas.remove(this.backgroundImage);
        }
        
        const canvasWidth = this.canvas.getWidth();
        const canvasHeight = this.canvas.getHeight();
        
        const backgroundRect = new fabric.Rect({
          left: 0,
          top: 0,
          width: canvasWidth,
          height: canvasHeight,
          fill: '#fafafa',
          stroke: '#9ca3af',
          strokeWidth: 2,
          selectable: false,
          evented: false,
          opacity: 0.9,
        });
        
        const text = new fabric.Text(`Background: ${file.name}\n(Visual placeholder)`, {
          left: canvasWidth / 2,
          top: canvasHeight / 2,
          fontSize: 16,
          fill: '#6b7280',
          textAlign: 'center',
          selectable: false,
          evented: false,
          originX: 'center',
          originY: 'center',
        });
        
        this.backgroundImage = new fabric.Group([backgroundRect, text], {
          selectable: false,
          evented: false,
        });
        
        this.canvas.add(this.backgroundImage);
        this.canvas.sendToBack(this.backgroundImage);
        
        if (this.gridGroup) {
          this.gridGroup.visible = false;
        }
        
        this.canvas.renderAll();
      }

      removeBackgroundImage() {
        if (this.backgroundImage) {
          this.canvas.remove(this.backgroundImage);
          this.backgroundImage = null;
          this.canvas.renderAll();
          if (this.gridGroup) {
            this.gridGroup.visible = this.gridVisible;
          }
        }
      }

      setBackgroundOpacity(opacity) {
        if (this.backgroundImage) {
          this.backgroundImage.set('opacity', opacity);
          this.canvas.renderAll();
        }
      }

      deleteRoom(roomId) {
        const room = this.rooms.get(roomId);
        if (room && room.fabricObject) {
          this.canvas.remove(room.fabricObject);
          this.rooms.delete(roomId);
          this.canvas.renderAll();
          this.notifyRoomsChange();
        }
      }

      updateRoomMaterial(roomId, material) {
        const room = this.rooms.get(roomId);
        if (room) {
          room.material = material;
          room.cost = this.calculateRoomCost(room);
          
          if (room.fabricObject) {
            room.fabricObject.set({
              fill: `${MATERIALS[material].color}40`,
              stroke: MATERIALS[material].color,
            });
            this.canvas.renderAll();
          }
          
          this.notifyRoomsChange();
        }
      }

      updateRoomName(roomId, name) {
        const room = this.rooms.get(roomId);
        if (room) {
          room.name = name;
          this.notifyRoomsChange();
        }
      }

      getRooms() {
        return Array.from(this.rooms.values());
      }

      getTotalCost() {
        return Array.from(this.rooms.values()).reduce((total, room) => total + room.cost, 0);
      }

      onRoomsChangeCallback(callback) {
        this.onRoomsChange = callback;
      }

      notifyRoomsChange() {
        if (this.onRoomsChange) {
          this.onRoomsChange(this.getRooms());
        }
      }
    }

    // Global variables
    let canvasManager;

    // Initialize the application
    function init() {
      const canvasElement = document.getElementById('canvas');
      canvasManager = new CanvasManager(canvasElement);
      canvasManager.onRoomsChangeCallback(updateUI);
      
      // Set default active tool
      document.getElementById('rect-btn').classList.add('active');
      
      // Populate templates dropdown
      const templateSelect = document.getElementById('template-select');
      TEMPLATES.forEach(template => {
        const opt = document.createElement('option');
        opt.value = JSON.stringify(template);
        opt.textContent = `${template.name} (${template.width}×${template.height})`;
        templateSelect.appendChild(opt);
      });
      
      // Update scale display
      updateScaleDisplay();
    }

    function updateScaleDisplay() {
      const scaleDisplay = document.getElementById('scale-display');
      if (scaleDisplay) {
        scaleDisplay.textContent = `${canvasManager.scaleFactor.toFixed(1)} pixels = 1m`;
      }
    }

    function updateUI(rooms) {
      const list = document.getElementById('rooms-list');
      list.innerHTML = '';
      
      if (rooms.length === 0) {
        list.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No elements yet. Draw on canvas or click "Add Element"</p>';
      } else {
        rooms.forEach(room => {
          const div = document.createElement('div');
          div.className = 'border border-gray-200 p-3 mb-2 rounded-lg bg-gray-50';
          div.innerHTML = `
            <input type="text" value="${room.name}" onchange="updateName('${room.id}', this.value)" class="w-full mb-2 p-1 border rounded text-sm">
            <div class="text-xs text-gray-600 mb-2">
              <p>Size: ${Math.round(room.width)} × ${Math.round(room.height)} units</p>
              <p>Real: ${Math.round(room.width/canvasManager.scaleFactor*10)/10} × ${Math.round(room.height/canvasManager.scaleFactor*10)/10} m</p>
              <p>Area: ${Math.round((room.width * room.height) / (canvasManager.scaleFactor * canvasManager.scaleFactor) * 100) / 100} m²</p>
            </div>
            <select onchange="updateMaterial('${room.id}', this.value)" class="w-full mb-2 p-1 border rounded text-sm">
              ${Object.keys(MATERIALS).map(k => `<option value="${k}" ${k === room.material ? 'selected' : ''}>${k.charAt(0).toUpperCase() + k.slice(1)}</option>`).join('')}
            </select>
            <div class="flex justify-between items-center">
              <span class="font-semibold text-green-600">$${room.cost}</span>
              <button onclick="deleteRoom('${room.id}')" class="bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded text-xs">Delete</button>
            </div>
          `;
          list.appendChild(div);
        });
      }

      document.getElementById('total-cost').textContent = `$${canvasManager.getTotalCost()} AUD`;
    }

    // UI Functions
    window.setShape = (shape) => canvasManager.setCurrentShape(shape);
    window.setMaterial = (mat) => canvasManager.setSelectedMaterial(mat);
    window.addElement = () => canvasManager.addRoom();
    window.clearCanvas = () => canvasManager.clearCanvas();
    window.toggleGrid = () => canvasManager.toggleGrid();
    window.zoomIn = () => canvasManager.zoomIn();
    window.zoomOut = () => canvasManager.zoomOut();
    window.zoomToFit = () => canvasManager.zoomToFit();
    window.loadBackground = () => {
      const file = document.getElementById('bg-file').files[0];
      if (file) canvasManager.loadBackgroundImage(file);
    };
    window.removeBackground = () => canvasManager.removeBackgroundImage();
    window.setBgOpacity = (val) => canvasManager.setBackgroundOpacity(parseFloat(val));
    window.deleteRoom = (id) => canvasManager.deleteRoom(id);
    window.updateMaterial = (id, mat) => canvasManager.updateRoomMaterial(id, mat);
    window.updateName = (id, name) => canvasManager.updateRoomName(id, name);

    // New enhanced functions
    window.startCalibration = () => canvasManager.startCalibration();
    
    window.addTemplate = () => {
      const templateSelect = document.getElementById('template-select');
      const selectedValue = templateSelect.value;
      if (selectedValue) {
        const template = JSON.parse(selectedValue);
        canvasManager.addTemplate(template);
        templateSelect.value = ''; // Reset selection
      } else {
        alert('Please select a template first.');
      }
    };

    window.addCustomMaterial = () => {
      const name = document.getElementById('custom-mat-name').value.trim();
      const color = document.getElementById('custom-mat-color').value;
      const cost = parseFloat(document.getElementById('custom-mat-cost').value);
      
      if (!name) {
        alert('Please enter a material name.');
        return;
      }
      if (isNaN(cost) || cost <= 0) {
        alert('Please enter a valid cost.');
        return;
      }
      
      canvasManager.addCustomMaterial(name, color, cost);
      
      // Clear form
      document.getElementById('custom-mat-name').value = '';
      document.getElementById('custom-mat-cost').value = '';
      
      alert(`Material "${name}" added successfully!`);
    };

    // Export Functions
    window.exportToCSV = () => {
      const rooms = canvasManager.getRooms();
      const csv = ['Name,Width (units),Height (units),Width (m),Height (m),Area (m²),Material,Cost (AUD)'];
      rooms.forEach(r => {
        const widthM = Math.round(r.width / canvasManager.scaleFactor * 10) / 10;
        const heightM = Math.round(r.height / canvasManager.scaleFactor * 10) / 10;
        const area = Math.round((r.width * r.height) / (canvasManager.scaleFactor * canvasManager.scaleFactor) * 100) / 100;
        csv.push(`"${r.name}",${r.width},${r.height},${widthM},${heightM},${area},${r.material},${r.cost}`);
      });
      csv.push(`,,,,,,Total,${canvasManager.getTotalCost()}`);
      csv.push(`,,,,,,Scale,"${canvasManager.scaleFactor.toFixed(1)} px/m"`);
      
      const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'construction_takeoff.csv';
      a.click();
      URL.revokeObjectURL(url);
    };

    window.exportToPDF = () => {
      alert('Premium Feature: PDF export includes detailed reports, measurements, and professional formatting. Upgrade to Pro to unlock this feature!');
    };

    window.saveProject = () => {
      const data = {
        rooms: canvasManager.getRooms().map(r => ({
          ...r,
          fabricObject: undefined,
          points: r.points,
        })),
        timestamp: new Date().toISOString(),
        version: '1.0'
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `buildcost_project_${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };

    window.loadProject = () => {
      const file = document.getElementById('load-file').files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          canvasManager.clearCanvas();
          
          data.rooms.forEach(r => {
            let obj;
            const base = {
              left: r.positionX,
              top: r.positionY,
              fill: `${MATERIALS[r.material].color}40`,
              stroke: MATERIALS[r.material].color,
              strokeWidth: r.shapeType === 'line' ? 4 : 2,
              selectable: true,
              evented: true,
            };
            
            switch (r.shapeType) {
              case 'rectangle':
                obj = new fabric.Rect({ ...base, width: r.width, height: r.height });
                break;
              case 'circle':
                obj = new fabric.Circle({ ...base, radius: r.width / 2 });
                break;
              case 'polygon':
                const points = [];
                for (let i = 0; i < r.points.length; i += 2) {
                  points.push({ x: r.points[i], y: r.points[i+1] });
                }
                obj = new fabric.Polygon(points, base);
                break;
              case 'line':
                obj = new fabric.Line([0, 0, r.width, r.height], base);
                break;
              case 'freehand':
                let pathStr = 'M ' + r.points[0] + ' ' + r.points[1];
                for (let i = 2; i < r.points.length; i += 2) {
                  pathStr += ' L ' + r.points[i] + ' ' + r.points[i+1];
                }
                obj = new fabric.Path(pathStr, { ...base, fill: '' });
                break;
            }
            
            if (obj) {
              canvasManager.canvas.add(obj);
              r.fabricObject = obj;
              canvasManager.rooms.set(r.id, r);
            }
          });
          
          canvasManager.notifyRoomsChange();
          alert('Project loaded successfully!');
        } catch (error) {
          alert('Error loading project file. Please check the file format.');
        }
      };
      reader.readAsText(file);
    };

    // Marketing Functions
    window.shareProject = () => {
      const url = window.location.href + '?shared=true';
      navigator.clipboard.writeText(url).then(() => {
        alert('Share link copied to clipboard! Note: Actual sharing requires server implementation.');
      }).catch(() => {
        alert('Share link: ' + url + '\n\nCopy this link to share your project!');
      });
    };

    window.subscribe = () => {
      alert('Redirecting to subscription page...\n\nPremium features include:\n• Unlimited PDF exports\n• Team collaboration\n• Template library\n• Priority support\n• Advanced reporting');
    };

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', init);

    // Add advertisement for free users
    setTimeout(() => {
      const ad = document.createElement('div');
      ad.className = 'ad-banner';
      ad.innerHTML = '🏗️ BuildCost Sketch - Professional takeoff tools for Australian builders • <strong>Upgrade to Pro</strong> to remove ads and unlock premium features!';
      document.body.appendChild(ad);
      
      // Auto-hide after 10 seconds
      setTimeout(() => {
        if (ad.parentNode) {
          ad.style.transform = 'translateY(100%)';
          setTimeout(() => ad.remove(), 300);
        }
      }, 10000);
    }, 3000);
  </script>
</body>
</html>